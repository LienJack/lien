webpackJsonp([1],{"+E39":function(r,n,t){r.exports=!t("S82l")(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},"+ZMJ":function(r,n,t){var e=t("lOnJ");r.exports=function(r,n,t){if(e(r),void 0===n)return r;switch(t){case 1:return function(t){return r.call(n,t)};case 2:return function(t,e){return r.call(n,t,e)};case 3:return function(t,e,o){return r.call(n,t,e,o)}}return function(){return r.apply(n,arguments)}}},"+tPU":function(r,n,t){t("xGkn");for(var e=t("7KvD"),o=t("hJx8"),i=t("/bQp"),a=t("dSzd")("toStringTag"),s="CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","),c=0;c<s.length;c++){var u=s[c],f=e[u],l=f&&f.prototype;l&&!l[a]&&o(l,a,u),i[u]=i.Array}},"/bQp":function(r,n){r.exports={}},"06OY":function(r,n,t){var e=t("3Eo+")("meta"),o=t("EqjI"),i=t("D2L2"),a=t("evD5").f,s=0,c=Object.isExtensible||function(){return!0},u=!t("S82l")(function(){return c(Object.preventExtensions({}))}),f=function(r){a(r,e,{value:{i:"O"+ ++s,w:{}}})},l=r.exports={KEY:e,NEED:!1,fastKey:function(r,n){if(!o(r))return"symbol"==typeof r?r:("string"==typeof r?"S":"P")+r;if(!i(r,e)){if(!c(r))return"F";if(!n)return"E";f(r)}return r[e].i},getWeak:function(r,n){if(!i(r,e)){if(!c(r))return!0;if(!n)return!1;f(r)}return r[e].w},onFreeze:function(r){return u&&l.NEED&&c(r)&&!i(r,e)&&f(r),r}}},"2KxR":function(r,n){r.exports=function(r,n,t,e){if(!(r instanceof n)||void 0!==e&&e in r)throw TypeError(t+": incorrect invocation!");return r}},"3A9s":function(r,n){r.exports="# 构造函数\r\n## 执行过程\r\n1. 使用new这个关键词来创建对象\r\n2. 在构造函数内部把新创建出来的对象赋予给this\r\n3. 在构造函数内部把新创建（将来new的对象）的属性方法绑到this上\r\n4. 默认是返回新创建的对象，特别需要注意的是如果显式return一个对象数据类型，那么将来new的对象，就是显式return的对象\r\n\r\n```\r\nfunction Person(name,age){\r\n // 2.给这个对象赋属性、方法，需要我们自己操作\r\n    this.name = name\r\n    this.age = age\r\n    this.eat = function(){\r\n        console.log(name + '吃饭')\r\n    }\r\n    \r\n    // 3.系统自动返回创建的对象\r\n    // return this\r\n}\r\n\r\nlet p1 = new Person(\"邵威儒\",28)\r\nconsole.log(p1.constructor) // Person 指向的构造函数是Person\r\n\r\nfunction Dog(name,age){\r\n    this.name = name\r\n    this.age = age\r\n}\r\n\r\nlet dog = new Dog(\"旺财\",10)\r\nconsole.log(dog.constructor) // Dog 指向的构造函数是Dog\r\n\r\n// 默认是返回新创建的对象，特别需要注意的是\r\n// 如果显式return一个对象数据类型，那么将来new的对象，就是显式return的对象\r\n// 这个是之前一个小伙伴问的，我们看下面的例子\r\n\r\n// 当我们显式return一个原始数据类型\r\nfunction Person(name,age){\r\n    this.name = name\r\n    this.age = age\r\n    \r\n    return \"1\"\r\n}\r\n\r\n\r\nlet p = new Person(\"邵威儒\",28) // { name: '邵威儒', age: 28 }\r\n\r\n// 当我们显式return一个对象数据类型时\r\nfunction Person(name,age){\r\n    this.name = name\r\n    this.age = age\r\n    \r\n    return [1,2,3]\r\n}\r\n\r\nlet p = new Person(\"邵威儒\",28) // [ 1, 2, 3 ]\r\n// 我们发现，当显式return一个对象数据类型时，我们new出来的对象，得到的是return的值\r\n```\r\n# 手动实现\r\n## 初步实现\r\n分析：\r\n因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。\r\n```javascript\r\nfunction objectFactory() {\r\n  var obj = {}\r\n  Constructor = [].shift.call(arguments)\r\n  obj.__proto__ = Constructor.prototype\r\n  Constructor.apply(obj, arguments)\r\n  return obj\r\n}\r\n```\r\n在这一版中，我们：\r\n1.用new Object() 的方式新建了一个对象 obj\r\n\r\n2.取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments\r\n会被去除第一个参数\r\n\r\n3.将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性\r\n\r\n4.使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性\r\n\r\n5.返回 obj\r\n\r\n```javascript\r\nfunction Otaku (name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n\r\n    this.habit = 'Games';\r\n}\r\n\r\nOtaku.prototype.strength = 60;\r\n\r\nOtaku.prototype.sayYourName = function () {\r\n    console.log('I am ' + this.name);\r\n}\r\n\r\nfunction objectFactory() {\r\n    var obj = new Object(),\r\n    Constructor = [].shift.call(arguments);\r\n    obj.__proto__ = Constructor.prototype;\r\n    Constructor.apply(obj, arguments);\r\n    return obj;\r\n};\r\n\r\nvar person = objectFactory(Otaku, 'Kevin', '18')\r\n\r\nconsole.log(person.name) // Kevin\r\nconsole.log(person.habit) // Games\r\nconsole.log(person.strength) // 60\r\n\r\nperson.sayYourName(); // I am Kevin\r\n```\r\n# 返回值效果实现\r\n接下来我们再来看一种情况，假如构造函数有返回值，举个例子：\r\n```javascript\r\nfunction Otaku (name, age) {\r\n    this.strength = 60;\r\n    this.age = age;\r\n\r\n    return {\r\n        name: name,\r\n        habit: 'Games'\r\n    }\r\n}\r\n\r\nvar person = new Otaku('Kevin', '18');\r\n\r\nconsole.log(person.name) // Kevin\r\nconsole.log(person.habit) // Games\r\nconsole.log(person.strength) // undefined\r\nconsole.log(person.age) // undefined\r\n```\r\n结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。\r\n所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。\r\n再来看第二版的代码，也是最后一版的代码：\r\n```javascript\r\n// 第二版的代码\r\nfunction objectFactory() {\r\n    var obj = new Object(),\r\n    Constructor = [].shift.call(arguments);\r\n    obj.__proto__ = Constructor.prototype;\r\n    var ret = Constructor.apply(obj, arguments);\r\n    return typeof ret === 'object' ? ret : obj;\r\n};\r\n```\r\n\r\n"},"3C/1":function(r,n,t){t("M6a0"),t("zQR9"),t("+tPU"),t("qCoq"),t("UvrK"),t("Xjd4"),t("bqnK"),r.exports=t("FeBl").Map},"3Eo+":function(r,n){var t=0,e=Math.random();r.exports=function(r){return"Symbol(".concat(void 0===r?"":r,")_",(++t+e).toString(36))}},"3fs2":function(r,n,t){var e=t("RY/4"),o=t("dSzd")("iterator"),i=t("/bQp");r.exports=t("FeBl").getIteratorMethod=function(r){if(void 0!=r)return r[o]||r["@@iterator"]||i[e(r)]}},"4WTo":function(r,n,t){var e=t("NWt+");r.exports=function(r,n){var t=[];return e(r,!1,t.push,t,n),t}},"4mcu":function(r,n){r.exports=function(){}},"52gC":function(r,n){r.exports=function(r){if(void 0==r)throw TypeError("Can't call method on  "+r);return r}},"77Pl":function(r,n,t){var e=t("EqjI");r.exports=function(r){if(!e(r))throw TypeError(r+" is not an object!");return r}},"7Doy":function(r,n,t){var e=t("EqjI"),o=t("7UMu"),i=t("dSzd")("species");r.exports=function(r){var n;return o(r)&&("function"!=typeof(n=r.constructor)||n!==Array&&!o(n.prototype)||(n=void 0),e(n)&&null===(n=n[i])&&(n=void 0)),void 0===n?Array:n}},"7KvD":function(r,n){var t=r.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=t)},"7UMu":function(r,n,t){var e=t("R9M2");r.exports=Array.isArray||function(r){return"Array"==e(r)}},"880/":function(r,n,t){r.exports=t("hJx8")},"94VQ":function(r,n,t){"use strict";var e=t("Yobk"),o=t("X8DO"),i=t("e6n0"),a={};t("hJx8")(a,t("dSzd")("iterator"),function(){return this}),r.exports=function(r,n,t){r.prototype=e(a,{next:o(1,t)}),i(r,n+" Iterator")}},"9Bbf":function(r,n,t){"use strict";var e=t("kM2E");r.exports=function(r){e(e.S,r,{of:function(){for(var r=arguments.length,n=new Array(r);r--;)n[r]=arguments[r];return new this(n)}})}},"9C8M":function(r,n,t){"use strict";var e=t("evD5").f,o=t("Yobk"),i=t("xH/j"),a=t("+ZMJ"),s=t("2KxR"),c=t("NWt+"),u=t("vIB/"),f=t("EGZi"),l=t("bRrM"),p=t("+E39"),v=t("06OY").fastKey,d=t("LIJb"),h=p?"_s":"size",y=function(r,n){var t,e=v(n);if("F"!==e)return r._i[e];for(t=r._f;t;t=t.n)if(t.k==n)return t};r.exports={getConstructor:function(r,n,t,u){var f=r(function(r,e){s(r,f,n,"_i"),r._t=n,r._i=o(null),r._f=void 0,r._l=void 0,r[h]=0,void 0!=e&&c(e,t,r[u],r)});return i(f.prototype,{clear:function(){for(var r=d(this,n),t=r._i,e=r._f;e;e=e.n)e.r=!0,e.p&&(e.p=e.p.n=void 0),delete t[e.i];r._f=r._l=void 0,r[h]=0},delete:function(r){var t=d(this,n),e=y(t,r);if(e){var o=e.n,i=e.p;delete t._i[e.i],e.r=!0,i&&(i.n=o),o&&(o.p=i),t._f==e&&(t._f=o),t._l==e&&(t._l=i),t[h]--}return!!e},forEach:function(r){d(this,n);for(var t,e=a(r,arguments.length>1?arguments[1]:void 0,3);t=t?t.n:this._f;)for(e(t.v,t.k,this);t&&t.r;)t=t.p},has:function(r){return!!y(d(this,n),r)}}),p&&e(f.prototype,"size",{get:function(){return d(this,n)[h]}}),f},def:function(r,n,t){var e,o,i=y(r,n);return i?i.v=t:(r._l=i={i:o=v(n,!0),k:n,v:t,p:e=r._l,n:void 0,r:!1},r._f||(r._f=i),e&&(e.n=i),r[h]++,"F"!==o&&(r._i[o]=i)),r},getEntry:y,setStrong:function(r,n,t){u(r,n,function(r,t){this._t=d(r,n),this._k=t,this._l=void 0},function(){for(var r=this._k,n=this._l;n&&n.r;)n=n.p;return this._t&&(this._l=n=n?n.n:this._t._f)?f(0,"keys"==r?n.k:"values"==r?n.v:[n.k,n.v]):(this._t=void 0,f(1))},t?"entries":"values",!t,!0),l(n)}}},ALrJ:function(r,n,t){var e=t("+ZMJ"),o=t("MU5D"),i=t("sB3e"),a=t("QRG4"),s=t("oeOm");r.exports=function(r,n){var t=1==r,c=2==r,u=3==r,f=4==r,l=6==r,p=5==r||l,v=n||s;return function(n,s,d){for(var h,y,m=i(n),x=o(m),g=e(s,d,3),b=a(x.length),j=0,S=t?v(n,b):c?v(n,0):void 0;b>j;j++)if((p||j in x)&&(y=g(h=x[j],j,m),r))if(t)S[j]=y;else if(y)switch(r){case 3:return!0;case 5:return h;case 6:return j;case 2:S.push(h)}else if(f)return!1;return l?-1:u||f?f:S}}},D2L2:function(r,n){var t={}.hasOwnProperty;r.exports=function(r,n){return t.call(r,n)}},DReE:function(r,n){r.exports="# 当前JavaScript编程主要是异步编程\r\n当前JavaScript编程主要是异步编程。为什么这么说呢？网页或Web开发最早从2005年Ajax流行开始，逐步向重交互时代迈进。特别是SPA（Single Page Application，单页应用）流行之后，一度有人提出“Web页面要转向Web应用，而且要媲美原生应用”。如今在前端开发组件化的背景下催生的Angular、React和Vue，都是SPA进一步演化的结果。\r\n\r\nWeb应用或开发重交互的特征越来越明显，意味着什么？意味着按照浏览器这个运行时的特性，页面在首次加载过程中，与JavaScript相关的主要任务就是加载基础运行库和扩展库（包括给低版本浏览器打补丁的脚本），然后初始化和设置页面的状态。首次加载之后，用户对页面的操作、数据I/O以及DOM更新，就全部交由异步JavaScript脚本管理。所以，目前JavaScript编程最大的应用是Web交互，而Web交互的核心就是异步逻辑\r\n\r\n然而，ES6之前JavaScript中控制异步流程的手段只有事件和回调。比如下面的示例展示了通过原生XMLHttpRequest对象发送异步请求，然后给onload和onerror事件分别注册成功和错误处理函数：\r\n\r\n```\r\n\r\nvar req = new XMLHttpRequest();\r\nreq.open('GET', url);\r\n \r\nreq.onload = function () {\r\n    if (req.status == 200) {\r\n        processData(req.response);\r\n    } \r\n};\r\n \r\nreq.onerror = function () {\r\n    console.log('Network Error');\r\n};\r\n \r\nreq.send();\r\n```\r\n事件和回调有很多问题，主要是它们只适用于简单的情况。逻辑一复杂，代码的编写和维护成本就成倍上升。比如，大家熟知的“回调地狱”。更重要的是，回调模式的异步本质与人类同步、顺序的思维模式是相悖的。\r\n为了应对越来越复杂的异步编程需求，ES6推出了解决上述问题的Promise。\r\n# Promise\r\nPromise，人们普遍的理解就是：“Promise是一个未来值的占位符”。也就是说，从语义上讲，一个Promise对象代表一个对未来值的“承诺”（promise），这个承诺将来如果“兑现”（fulfill），就会“解决”（resolve）为一个有意义的数据；如果“拒绝”（reject），就会“解决”为一个“拒绝理由”（rejection reason），就是一个错误消息。\r\n\r\nPromise对象的状态很简单，一生下来的状态是pending（待定），将来兑现了，状态变成fulfilled；拒绝了，状态变成rejected。fulfilled和rejected显然是一种“确定”（settled）状态。以上状态转换是不可逆的，所以Promise很单纯，好控制，哈哈。\r\n\r\n![image](https://file.webstacks.cn/2018/08/2018082709034577.png)\r\n\r\n\r\n以下是Promise相关的所有API。前3个是创建Promise对象的（稍后有例子），后4个中的前2个是用于注册反应函数的（稍后有例子），后2个是用于控制并发和抢占的：\r\n\r\n![image](https://file.webstacks.cn/2018/08/2018082709043541.png)\r\n\r\n\r\n以下是通过Prmoise(executor)构造函数创建Promise实例的详细过程：要传入一个“执行函数”（executor），这个执行函数又接收两个参数“解决函数”（resolver）和“拒绝函数”（rejector），代码中分别对应变量resolve和reject，作用分别是将新建对象的状态由pending改为fulfilled和rejected，同时返回“兑现值”（fulfillment）和“拒绝理由”（rejection）。当然，resolve和reject都是在异步操作的回调中调用的。调用之后，运行时环境（浏览器引擎或Node.js的libuv）中的事件循环调度机制会把与之相关的反应函数——兑现反应函数或拒绝反应函数以及相关的参数添加到“微任务”队列，以便下一次“循检”（tick）时调度到JavaScript线程去执行。\r\n\r\n[微任务](http://note.youdao.com/noteshare?id=60f3511e29305697e4235876b8eb193b&sub=2094F3F092B8479290A0AA45E358984D)\r\n\r\n![image](https://file.webstacks.cn/2018/08/2018082709061866.png)\r\n\r\n如前所述，Promise对象的状态由pending变成fulfilled，就会执行“兑现反应函数”（fulfillment reaction）；而变成rejected，就会执行“拒绝反应函数”（rejection reaction）。如下例所示，常规的方式是通过p.then()注册兑现函数，通过p.catch()注册拒绝函数：\r\n\r\n\r\n```\r\np.then(res => { // 兑现反应函数\r\n  // res === 'random success'\r\n})\r\np.catch(err => { // 拒绝反应函数\r\n  // err === 'random failure'\r\n})\r\n```\r\n\r\n当然还有非常规的方式，而且有时候非常规方式可能更好用：\r\n\r\n\r\n```\r\n// 通过一个.then()方法同时注册兑现和拒绝函数\r\np.then(\r\n  res => {\r\n    // handle response\r\n  },\r\n  err => {\r\n    // handle error\r\n  }\r\n)\r\n// 通过.then()方法只注册一个函数：兑现函数\r\np.then(res => {\r\n  // handle response\r\n})\r\n// 通过.then()方法只传入拒绝函数，兑现函数的位置传null\r\np.then(null, err => {\r\n  // handle error\r\n})\r\n```\r\n\r\n关于Promise就这样吧。ES6除了Promise，还推出了Iterator（迭代器）和Generator（生成器），于是就有成就Async函数的PIG组合。下面我们分别简单看一看Iterator和Generator。\r\n\r\n# Iterator\r\n要理解Iterator或者迭代器，最简单的方式是看它的接口：\r\n\r\n```\r\ninterface IteratorResult {\r\n  done: boolean;\r\n  value: any;\r\n}\r\ninterface Iterator {\r\n  next(): IteratorResult;\r\n}\r\ninterface Iterable {\r\n  [Symbol.iterator](): Iterator\r\n}\r\n```\r\n先从中间的Iterator看。\r\n\r\n什么是迭代器？它是一个对象，有一个next()方法，每次调用next()方法，就会返回一个迭代器结果（看第一个接口IteratorResult）。而这个迭代器结果，同样还是一个对象，这个对象有两个属性：done和value，其中done是一个布尔值，false表示迭代器迭代的序列没有结束；true表示迭代器迭代的序列结束了。而value就是迭代器每次迭代真正返回的值。\r\n\r\n再看最后一个接口Iterable，翻译成“可迭代对象”，它有一个[Symbol.iterator]()方法，这个方法会返回一个迭代器。\r\n\r\n可以结合前面的接口定义和下面这张图来理解可迭代对象（实现了“可迭代协议”）、迭代器（实现了“迭代器协议”）和迭代器结果这3个简单而又重要的概念（暂时理解不了也没关系，后面还有一个无穷序列的例子，可以帮助大家理解）。\r\n\r\n![image](851F007D17674795A7A2BF487E93267E)\r\n\r\n可迭代对象是一个我们非常熟悉的概念，数组、字符串以及ES6新增的集合类型Set和Map都是可迭代对象。这意味着什么呢？意味着我们可以通过E6新增的3个用于操作可迭代对象的语法：\r\n- for...of\r\n- [...iterable]\r\n- Array.from(iterable)\r\n\r\n下面再看一个通过迭代器创建无穷序列的小例子，通过这个例子我们再来深入理解与迭代器相关的概念。\r\n\r\n\r\n```\r\nconst random = {\r\n  [Symbol.iterator]: () => ({\r\n    next: () => ({ value: Math.random() })\r\n  })\r\n}\r\n \r\n// 运行这行代码会怎么样？\r\n[...random]\r\n// 这行呢？\r\nArray.from(random)\r\n```\r\n这个例子使用两个ES6的箭头函数定义了两个方法，创建了三个对象。\r\n\r\n最内层的对象{ value: Math.random() }很明显是一个“迭代器结果”（IteratorResult）对象，因为它有一个value属性和一个……，等等，done属性呢？这里没有定义done属性，所以每次迭代（调用next()）时访问IteratorResult.done都会返回false；所以这个迭代器结果的定义相当于{ value: Math.random() , done: false }。显然，done永远不可能是true，所以这是一个无穷随机数序列！\r\n\r\n\r\n```\r\ninterface IteratorResult {\r\n  done: boolean;\r\n  value: any;\r\n}\r\n```\r\n再往外看，返回这个迭代器结果对象的箭头函数被赋值给了外层对象的next()方法。根据Iterator接口的定义，如果一个对象包含一个next()方法，而这个方法的返回值又是一个迭代器结果，那么这个对象是什么？没错，就是迭代器。好，第二个对象是一个迭代器！\r\n\r\n\r\n```\r\ninterface Iterator {\r\n  next(): IteratorResult;\r\n}\r\n```\r\n\r\n再往外看，返回这个迭代器对象的箭头函数被赋值给了外层对象的[Symbol.iterator]()方法。根据Iterable接口的定义，如果一个对象包含一个[Symbol.iterator]()方法，而这个方法的返回值又是一个迭代器，那么这个对象是什么？没错，就是可迭代对象。\r\n\r\n\r\n```\r\ninterface Iterable {\r\n  [Symbol.iterator](): Iterator\r\n}\r\n```\r\n\r\n好，到现在我们应该彻底理解迭代器及其相关概念了。下面继续看例子。前面的例子定义了一个可迭代对象random，这个对象的迭代器可以无限返回随机数，所以：\r\n\r\n\r\n```\r\n// 运行这行代码会怎么样？\r\n[...random]\r\n// 这行呢？\r\nArray.from(random)\r\n```\r\n是的，这两行代码都会导致程序（或运行时）崩溃！因为迭代器会不停地运行，阻塞JavaScript执行线程，最终可能因占满可用内存导致运行时停止响应，甚至崩溃。\r\n\r\n# Generator\r\n\r\n依例，上接口：\r\n\r\n```\r\ninterface Generator extends Iterator {\r\n    next(value?: any): IteratorResult;\r\n    [Symbol.iterator](): Iterator;\r\n    throw(exception: any);\r\n}\r\n```\r\n能看来出生成器是什么吗？仅从它的接口来看，它既是一个迭代器，又是一个可迭代对象。没错，生成器因此又是迭代器的“加强版”，为什么？因为生成器还提供了一个关键字yield，它返回的序列值会自动包装在一个IteratorResult（迭代器结果）对象中，省去了我们手工编写相应代码的麻烦。下面就是一个生成器函数的定义：\r\n\r\n\r\n```\r\nfunction *gen() {\r\n  yield 'a'\r\n  yield 'b'\r\n  return 'c'\r\n}\r\n```\r\n\r\n哎，接口定义的生成器不是一个对象吗，怎么是一个函数啊？\r\n实际上，说生成器是对象或是函数都不确切。但我们知道，调用生成器函数会返回一个迭代器（接口描述的就是这个对象），这个迭代器可以控制返回它的生成器函数封装的逻辑和数据。从这个意义上说，生成器由生成器函数及其返回的迭代器两部分组成。再换句话说，生成器是一个笼统的概念，是一个统称。（别急，一会你就明白这样理解生成器的意义何在了。）\r\n\r\n本节刚开始说了，生成器（返回的对象）“既是一个迭代器，又是一个可迭代对象”。下面我们就来验证一下：\r\n\r\n\r\n```\r\nconst chars = gen()\r\ntypeof chars[Symbol.iterator] === 'function' // chars是可迭代对象\r\ntypeof chars.next === 'function'  // chars是迭代器\r\nchars[Symbol.iterator]() === chars  // chars的迭代器就是它本身\r\nconsole.log(Array.from(chars))  // 可以对它使用Array.from\r\n// ['a', 'b']\r\nconsole.log([...chars]) // 可以对它使用Array.from\r\n// ['a', 'b']\r\n```\r\n\r\n通过代码中的注释我们得到了全部答案。这里有个小问题：“为什么迭代这个生成器返回的序列值中不包含字符'c'呢？”\r\n\r\n原因在于，yield返回的迭代器结果对象的done属性值都为false，所以'a'和'b'都是有效的序列值；而return返回的虽然也是迭代器结果对象，但done属性的值却是true，true表示序列结束，所以'c'不会包含在迭代结果中。（如果没有return语句，代码执行到生成器函数末尾，会隐式返回{ value: undefined, done: true}。相信这一点不说你也知道。）\r\n\r\n以上只是生成器作为“加强版”迭代器的一面。接下来，我们要接触生成器真正强大的另一面了！\r\n\r\n生成器真正强大的地方，也是它有别于迭代器的地方，在于它不仅能在每次迭代返回值，而且还能接收值。（当然，生成器的概念里本身就有生成器函数嘛！函数当然可以接收参数喽。）等等，可不仅仅是可以给生成器函数传参，而是还可以给yield表达式传参！\r\n\r\n\r\n```\r\nfunction *gen(x) {\r\n  const y = x * (yield)\r\n  return y\r\n}\r\n\r\nconst it = gen(6)\r\nit.next()\r\n// {value: undefined, done: false}\r\nit.next(7)\r\n// {value: 42, done: true}\r\n```\r\n\r\n在上面这个简单的生成器的例子中。我们定义了一个生成器函数*gen()，它接收一个参数x。函数体内只有一个yield表达式，好像啥也没干。但是，yield表达式似乎是一个“值的占位符”，因为代码在某个时刻会计算变量x与这个“值”的乘积，并把该乘积赋值给变量y。最后，函数返回y。\r\n\r\n这有点费解，下面我们一步一步分析。\r\n\r\n1. 调用gen(6)创建生成器的迭代器it（前面说了，生成器包含迭代器及返回它的生成器函数），传入数值6。\r\n2. 调用it.next()启动生成器。此时生成器函数的代码执行到第一个yield表达式处暂停，并返回undefined。（yield并没闲着，它看后面没有显式要返回的值，就只能返回默认的undefined。）\r\n3. 调用it.next(7)恢复生成器执行。此时yield接收到传入的数值7，立即恢复生成器函数代码的执行，并把自己替换成数值7。\r\n4. 代码计算：6 * 7，得到42，并把42赋给变量y，最后返回y。\r\n5. 生成器函数最终返回的值就是：{value: 42, done: true}\r\n\r\n这个例子中只有一个yield，假如还有更多的yield，则第4步会到第二个yield处再次暂停生成器函数的执行，返回一个值，之后重复第3、4步，即还可以通过再调用it.next()向生成器函数中传入值。\r\n\r\n我们简单总结一下，每次调用it.next()，可能有下列4种情况导致生成器暂停或停止执行：\r\n\r\n- yield表达式返回序列中下一个值\r\n- return语句返回生成器函数的值（{ done: true }）\r\n- throw语句完全停止生成器执行（后面会详细解释）\r\n- 到达生成器函数最后，隐式返回{ value: undefined, done: true}\r\n\r\n下面来看一个使用 await 的例子：\r\n\r\n```\r\nlet a = 0\r\nlet b = async () => {\r\n  a = a + await 10\r\n  console.log('2', a) // -> '2' 10\r\n}\r\nb()\r\na++\r\nconsole.log('1', a) // -> '1' 1\r\n```\r\n对于以上代码你可能会有疑惑，让我来解释下原因\r\n- 首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来\r\n- 因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码\r\n- 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10\r\n\r\n# 异步迭代生成器\r\n前面我们看到的对生成器的迭代传值，包括传递错误，都是同步的。实际上，生成器的yield表达式真正（哦，又一个“真正”）强大的地方在于：它在暂停生成器代码执行以后，不是必须等待迭代器代码同步调用it.next()方法给它返回值，而是可以让迭代器在一个异步操作的回调中取得返回值，然后再通过it.next(res)把值传给它。\r\n\r\n明白了吗？yield可以等待一个异步操作的结果。从而让本文开始提到的这种看似不可能的情况变成可能：\r\n\r\n\r\n```\r\nconst r1 = ajax('url')\r\nconsole.log(r1)\r\n// undefined\r\n```\r\n\r\n怎么变呢，在异步操作前加个yield呀：\r\n\r\n\r\n```\r\nconst r1 = yield ajax('url')\r\nconsole.log(r1)\r\n// 这次r1就是真正的响应结果了\r\n```\r\n\r\n我们还是以一个返回Promise的异步操作为例来说明这一点比较好。因为基于回调的异步操作，很容易可以转换成基于Promise的异步操作（比如jQuery的$.ajax()或通过util.promisify把Node.js中的异步方法转换成Promise）。\r\n\r\n例子来了。这是一个纯Promise的例子。\r\n\r\n\r\n```\r\nfunction foo(x,y) {\r\n  return request(\r\n    \"http://some.url.1/?x=\" + x + \"&y=\" + y\r\n  );\r\n}\r\n\r\nfoo(11, 31)\r\n  .then(\r\n    function(text){\r\n      console.log(text);\r\n    },\r\n    function(err){\r\n      console.error(err);\r\n    }\r\n);\r\n```\r\n\r\n函数foo(x, y)封装了一个异步request请求，返回一个Promise。调用foo(11, 31)传入参数后，request就向拼接好的URL发送请求，返回待定（pending）状态的Promise对象。请求成功，则执行then()中注册的兑现反应函数，处理响应；请求失败，则执行拒绝反应函数，处理错误。\r\n\r\n接下来我们要做的，就是将上面的代码与生成器结合，让生成器只关注发送请求和取得响应结果，而把异步操作的等待和回调处理逻辑作为实现细节抽象出来。（“作为细节”，对，我们的目标是只关注请求和结果，过程嘛，都是细节，哈哈～。）\r\n\r\n```\r\nfunction foo(x, y) {\r\n  return request(\r\n    \"http://some.url.1/?x=\" + x + \"&y=\" + y\r\n  );\r\n}\r\nfunction *main() {\r\n  try {\r\n    const result = yield foo(11, 31);  // 异步函数调用！\r\n    console.log( result );\r\n  } catch (err) {\r\n    console.error( err );\r\n  }\r\n}\r\nconst it = main(); \r\nconst p = it.next().value; // 启动生成器并取得Promise `p`\r\n\r\np.then( // 等待Promise `p`解决\r\n  function(res){\r\n    it.next(res);  // 把`text`传给`*main()`并恢复其执行\r\n  },\r\n  function(err){\r\n    it.throw(err);  // 把`err`抛到`*main()`\r\n  }\r\n);\r\n```\r\n\r\n注意，生成器函数（*main）的yield表达式中出现了异步函数调用：foo(11, 31)。而我们就要做的，就是在迭代器代码中通过it.next()拿到这个异步函数调用返回的Promise，然后正确地处理它。怎么处理？我们看代码。\r\n\r\n创建生成器的迭代器之后，const p = it.next().value;返回了Promise p。在p的兑现反应函数中，我们把拿到的响应res通过it.next(res)调用传回了生成器函数中的yield。yield拿到响应结果res之后，立即恢复生成器代码的执行，把res赋值给变量result。于是，我们成功地在生成器函数中，以同步代码的书写方式取得了异步请求的响应结果！神奇不？\r\n\r\n好啦，目标达成：我们利用生成器的同步代码，实现了对异步操作的完美控制。然而，还有一个问题。上面例子中的生成器只包装了一个异步操作，如果是多个异步操作怎么办呢？这时候，最好有一段通用的用于处理生成器函数的代码，无论其中包含多少异步操作，这段代码都能自动完成对Promise的接收、等待和响应/错误传递等这些“细节”工作。\r\n\r\n那不就是一个基于Promise的生成器运行程序吗？\r\n\r\n# 通用的生成器运行程序\r\n综前所述，我们想要的是这样一个结果：\r\n\r\n\r\n```\r\nfunction example() {\r\n  return run(function *() {\r\n    const r1 = yield new Promise(resolve =>\r\n      setTimeout(resolve, 500, 'slowest')\r\n    )\r\n    const r2 = yield new Promise(resolve =>\r\n      setTimeout(resolve, 200, 'slow')\r\n    )\r\n    return [r1, r2]\r\n  })\r\n}\r\n \r\nexample().then(result => console.log(result))\r\n// ['slowest', 'slow']\r\n```\r\n\r\n即定义一个通用的运行函数run，它负责处理传给它的生成器函数中包装的任意多个异步操作。针对每个操作，它都会正确地返回异步结果，或者向生成器函数中抛出异常。而运行这个函数的最终结果，也是返回一个Promise，这个Promise包含生成器函数返回的所有异步操作的结果（上例）。\r\n\r\n# 为什么说Async函数是语法糖\r\n有了这个运行函数，我们可以比较一下下面两个example()函数:\r\n\r\n![image](184441792CB74C90BA8ABBAC80DDD908)\r\n\r\n第一个example()是通过生成器运行程序控制异步代码；第二个example()是一个异步（Async）函数，通过async/await控制异步代码。\r\n\r\n它们的区别只在于前者多了一层run函数封装，使用yield而不是await，而且没有async关键字修饰。除此之外，核心代码完全一样！\r\n\r\n现在，大家再看到类似下面的异步函数，能想到什么？\r\n\r\n\r\n```\r\nasync function example() {\r\n  const r1 = await new Promise(resolve =>\r\n    setTimeout(resolve, 500, 'slowest')\r\n  )\r\n  const r2 = await new Promise(resolve =>\r\n    setTimeout(resolve, 200, 'slow')\r\n  )\r\n  return [r1, r2]\r\n}\r\n \r\nexample().then(result => console.log(result))\r\n// ['slowest', 'slow']\r\n```\r\n\r\n是的，Async函数或者说async/await就是基于Promise、Iterator和Generator构造的一块充满苦涩和香甜、让人回味无穷的“语法糖”！记住，Async function = Promise + Iterator + Generator，或者“Async函数原来是PIG”。\r\n\r\n# 链接\r\n[Async函数原来是PIG](https://www.webstacks.cn/tutorial/1584.html)\r\n\r\n\r\n\r\n\r\n\r\n"},EGZi:function(r,n){r.exports=function(r,n){return{value:n,done:!!r}}},EqjI:function(r,n){r.exports=function(r){return"object"==typeof r?null!==r:"function"==typeof r}},FeBl:function(r,n){var t=r.exports={version:"2.6.1"};"number"==typeof __e&&(__e=t)},HpRW:function(r,n,t){"use strict";var e=t("kM2E"),o=t("lOnJ"),i=t("+ZMJ"),a=t("NWt+");r.exports=function(r){e(e.S,r,{from:function(r){var n,t,e,s,c=arguments[1];return o(this),(n=void 0!==c)&&o(c),void 0==r?new this:(t=[],n?(e=0,s=i(c,arguments[2],2),a(r,!1,function(r){t.push(s(r,e++))})):a(r,!1,t.push,t),new this(t))}})}},Ibhu:function(r,n,t){var e=t("D2L2"),o=t("TcQ7"),i=t("vFc/")(!1),a=t("ax3d")("IE_PROTO");r.exports=function(r,n){var t,s=o(r),c=0,u=[];for(t in s)t!=a&&e(s,t)&&u.push(t);for(;n.length>c;)e(s,t=n[c++])&&(~i(u,t)||u.push(t));return u}},LIJb:function(r,n,t){var e=t("EqjI");r.exports=function(r,n){if(!e(r)||r._t!==n)throw TypeError("Incompatible receiver, "+n+" required!");return r}},M6a0:function(r,n){},MU5D:function(r,n,t){var e=t("R9M2");r.exports=Object("z").propertyIsEnumerable(0)?Object:function(r){return"String"==e(r)?r.split(""):Object(r)}},Mhyx:function(r,n,t){var e=t("/bQp"),o=t("dSzd")("iterator"),i=Array.prototype;r.exports=function(r){return void 0!==r&&(e.Array===r||i[o]===r)}},MmMw:function(r,n,t){var e=t("EqjI");r.exports=function(r,n){if(!e(r))return r;var t,o;if(n&&"function"==typeof(t=r.toString)&&!e(o=t.call(r)))return o;if("function"==typeof(t=r.valueOf)&&!e(o=t.call(r)))return o;if(!n&&"function"==typeof(t=r.toString)&&!e(o=t.call(r)))return o;throw TypeError("Can't convert object to primitive value")}},"NWt+":function(r,n,t){var e=t("+ZMJ"),o=t("msXi"),i=t("Mhyx"),a=t("77Pl"),s=t("QRG4"),c=t("3fs2"),u={},f={};(n=r.exports=function(r,n,t,l,p){var v,d,h,y,m=p?function(){return r}:c(r),x=e(t,l,n?2:1),g=0;if("function"!=typeof m)throw TypeError(r+" is not iterable!");if(i(m)){for(v=s(r.length);v>g;g++)if((y=n?x(a(d=r[g])[0],d[1]):x(r[g]))===u||y===f)return y}else for(h=m.call(r);!(d=h.next()).done;)if((y=o(h,x,d.value,n))===u||y===f)return y}).BREAK=u,n.RETURN=f},O4g8:function(r,n){r.exports=!0},ON07:function(r,n,t){var e=t("EqjI"),o=t("7KvD").document,i=e(o)&&e(o.createElement);r.exports=function(r){return i?o.createElement(r):{}}},PzxK:function(r,n,t){var e=t("D2L2"),o=t("sB3e"),i=t("ax3d")("IE_PROTO"),a=Object.prototype;r.exports=Object.getPrototypeOf||function(r){return r=o(r),e(r,i)?r[i]:"function"==typeof r.constructor&&r instanceof r.constructor?r.constructor.prototype:r instanceof Object?a:null}},QRG4:function(r,n,t){var e=t("UuGF"),o=Math.min;r.exports=function(r){return r>0?o(e(r),9007199254740991):0}},R9M2:function(r,n){var t={}.toString;r.exports=function(r){return t.call(r).slice(8,-1)}},RPLV:function(r,n,t){var e=t("7KvD").document;r.exports=e&&e.documentElement},"RY/4":function(r,n,t){var e=t("R9M2"),o=t("dSzd")("toStringTag"),i="Arguments"==e(function(){return arguments}());r.exports=function(r){var n,t,a;return void 0===r?"Undefined":null===r?"Null":"string"==typeof(t=function(r,n){try{return r[n]}catch(r){}}(n=Object(r),o))?t:i?e(n):"Object"==(a=e(n))&&"function"==typeof n.callee?"Arguments":a}},S82l:function(r,n){r.exports=function(r){try{return!!r()}catch(r){return!0}}},SfB7:function(r,n,t){r.exports=!t("+E39")&&!t("S82l")(function(){return 7!=Object.defineProperty(t("ON07")("div"),"a",{get:function(){return 7}}).a})},TcQ7:function(r,n,t){var e=t("MU5D"),o=t("52gC");r.exports=function(r){return e(o(r))}},UuGF:function(r,n){var t=Math.ceil,e=Math.floor;r.exports=function(r){return isNaN(r=+r)?0:(r>0?e:t)(r)}},UvrK:function(r,n,t){var e=t("kM2E");e(e.P+e.R,"Map",{toJSON:t("m9gC")("Map")})},WNaz:function(r,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var e=t("ifoU"),o=t.n(e),i=t("yaCO"),a=t.n(i),s=t("3A9s"),c=t.n(s),u=t("DReE"),f=t.n(u),l=new o.a;l.set("closure",a.a),l.set("prototype",c.a),l.set("async",f.a);var p={created:function(){var r=this.$route.params.title;r&&l.has(r)&&(this.value=l.get(""+r))},data:function(){return{value:"# 404没有找到文章"}}},v={render:function(){var r=this.$createElement,n=this._self._c||r;return n("div",{staticClass:"editor"},[n("mavon-editor",{attrs:{defaultOpen:"preview",toolbarsFlag:!1,value:this.value,subfield:!1,editable:!1}})],1)},staticRenderFns:[]};var d=t("VU/8")(p,v,!1,function(r){t("sHho")},"data-v-0eb2ced1",null);n.default=d.exports},X8DO:function(r,n){r.exports=function(r,n){return{enumerable:!(1&r),configurable:!(2&r),writable:!(4&r),value:n}}},Xjd4:function(r,n,t){t("9Bbf")("Map")},Yobk:function(r,n,t){var e=t("77Pl"),o=t("qio6"),i=t("xnc9"),a=t("ax3d")("IE_PROTO"),s=function(){},c=function(){var r,n=t("ON07")("iframe"),e=i.length;for(n.style.display="none",t("RPLV").appendChild(n),n.src="javascript:",(r=n.contentWindow.document).open(),r.write("<script>document.F=Object<\/script>"),r.close(),c=r.F;e--;)delete c.prototype[i[e]];return c()};r.exports=Object.create||function(r,n){var t;return null!==r?(s.prototype=e(r),t=new s,s.prototype=null,t[a]=r):t=c(),void 0===n?t:o(t,n)}},ax3d:function(r,n,t){var e=t("e8AB")("keys"),o=t("3Eo+");r.exports=function(r){return e[r]||(e[r]=o(r))}},bRrM:function(r,n,t){"use strict";var e=t("7KvD"),o=t("FeBl"),i=t("evD5"),a=t("+E39"),s=t("dSzd")("species");r.exports=function(r){var n="function"==typeof o[r]?o[r]:e[r];a&&n&&!n[s]&&i.f(n,s,{configurable:!0,get:function(){return this}})}},bqnK:function(r,n,t){t("HpRW")("Map")},dSzd:function(r,n,t){var e=t("e8AB")("wks"),o=t("3Eo+"),i=t("7KvD").Symbol,a="function"==typeof i;(r.exports=function(r){return e[r]||(e[r]=a&&i[r]||(a?i:o)("Symbol."+r))}).store=e},e6n0:function(r,n,t){var e=t("evD5").f,o=t("D2L2"),i=t("dSzd")("toStringTag");r.exports=function(r,n,t){r&&!o(r=t?r:r.prototype,i)&&e(r,i,{configurable:!0,value:n})}},e8AB:function(r,n,t){var e=t("FeBl"),o=t("7KvD"),i=o["__core-js_shared__"]||(o["__core-js_shared__"]={});(r.exports=function(r,n){return i[r]||(i[r]=void 0!==n?n:{})})("versions",[]).push({version:e.version,mode:t("O4g8")?"pure":"global",copyright:"© 2018 Denis Pushkarev (zloirock.ru)"})},evD5:function(r,n,t){var e=t("77Pl"),o=t("SfB7"),i=t("MmMw"),a=Object.defineProperty;n.f=t("+E39")?Object.defineProperty:function(r,n,t){if(e(r),n=i(n,!0),e(t),o)try{return a(r,n,t)}catch(r){}if("get"in t||"set"in t)throw TypeError("Accessors not supported!");return"value"in t&&(r[n]=t.value),r}},fkB2:function(r,n,t){var e=t("UuGF"),o=Math.max,i=Math.min;r.exports=function(r,n){return(r=e(r))<0?o(r+n,0):i(r,n)}},h65t:function(r,n,t){var e=t("UuGF"),o=t("52gC");r.exports=function(r){return function(n,t){var i,a,s=String(o(n)),c=e(t),u=s.length;return c<0||c>=u?r?"":void 0:(i=s.charCodeAt(c))<55296||i>56319||c+1===u||(a=s.charCodeAt(c+1))<56320||a>57343?r?s.charAt(c):i:r?s.slice(c,c+2):a-56320+(i-55296<<10)+65536}}},hJx8:function(r,n,t){var e=t("evD5"),o=t("X8DO");r.exports=t("+E39")?function(r,n,t){return e.f(r,n,o(1,t))}:function(r,n,t){return r[n]=t,r}},ifoU:function(r,n,t){r.exports={default:t("3C/1"),__esModule:!0}},kM2E:function(r,n,t){var e=t("7KvD"),o=t("FeBl"),i=t("+ZMJ"),a=t("hJx8"),s=t("D2L2"),c=function(r,n,t){var u,f,l,p=r&c.F,v=r&c.G,d=r&c.S,h=r&c.P,y=r&c.B,m=r&c.W,x=v?o:o[n]||(o[n]={}),g=x.prototype,b=v?e:d?e[n]:(e[n]||{}).prototype;for(u in v&&(t=n),t)(f=!p&&b&&void 0!==b[u])&&s(x,u)||(l=f?b[u]:t[u],x[u]=v&&"function"!=typeof b[u]?t[u]:y&&f?i(l,e):m&&b[u]==l?function(r){var n=function(n,t,e){if(this instanceof r){switch(arguments.length){case 0:return new r;case 1:return new r(n);case 2:return new r(n,t)}return new r(n,t,e)}return r.apply(this,arguments)};return n.prototype=r.prototype,n}(l):h&&"function"==typeof l?i(Function.call,l):l,h&&((x.virtual||(x.virtual={}))[u]=l,r&c.R&&g&&!g[u]&&a(g,u,l)))};c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,r.exports=c},lOnJ:function(r,n){r.exports=function(r){if("function"!=typeof r)throw TypeError(r+" is not a function!");return r}},lktj:function(r,n,t){var e=t("Ibhu"),o=t("xnc9");r.exports=Object.keys||function(r){return e(r,o)}},m9gC:function(r,n,t){var e=t("RY/4"),o=t("4WTo");r.exports=function(r){return function(){if(e(this)!=r)throw TypeError(r+"#toJSON isn't generic");return o(this)}}},msXi:function(r,n,t){var e=t("77Pl");r.exports=function(r,n,t,o){try{return o?n(e(t)[0],t[1]):n(t)}catch(n){var i=r.return;throw void 0!==i&&e(i.call(r)),n}}},oeOm:function(r,n,t){var e=t("7Doy");r.exports=function(r,n){return new(e(r))(n)}},qCoq:function(r,n,t){"use strict";var e=t("9C8M"),o=t("LIJb");r.exports=t("qo66")("Map",function(r){return function(){return r(this,arguments.length>0?arguments[0]:void 0)}},{get:function(r){var n=e.getEntry(o(this,"Map"),r);return n&&n.v},set:function(r,n){return e.def(o(this,"Map"),0===r?0:r,n)}},e,!0)},qio6:function(r,n,t){var e=t("evD5"),o=t("77Pl"),i=t("lktj");r.exports=t("+E39")?Object.defineProperties:function(r,n){o(r);for(var t,a=i(n),s=a.length,c=0;s>c;)e.f(r,t=a[c++],n[t]);return r}},qo66:function(r,n,t){"use strict";var e=t("7KvD"),o=t("kM2E"),i=t("06OY"),a=t("S82l"),s=t("hJx8"),c=t("xH/j"),u=t("NWt+"),f=t("2KxR"),l=t("EqjI"),p=t("e6n0"),v=t("evD5").f,d=t("ALrJ")(0),h=t("+E39");r.exports=function(r,n,t,y,m,x){var g=e[r],b=g,j=m?"set":"add",S=b&&b.prototype,w={};return h&&"function"==typeof b&&(x||S.forEach&&!a(function(){(new b).entries().next()}))?(b=n(function(n,t){f(n,b,r,"_c"),n._c=new g,void 0!=t&&u(t,m,n[j],n)}),d("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","),function(r){var n="add"==r||"set"==r;r in S&&(!x||"clear"!=r)&&s(b.prototype,r,function(t,e){if(f(this,b,r),!n&&x&&!l(t))return"get"==r&&void 0;var o=this._c[r](0===t?0:t,e);return n?this:o})}),x||v(b.prototype,"size",{get:function(){return this._c.size}})):(b=y.getConstructor(n,r,m,j),c(b.prototype,t),i.NEED=!0),p(b,r),w[r]=b,o(o.G+o.W+o.F,w),x||y.setStrong(b,r,m),b}},sB3e:function(r,n,t){var e=t("52gC");r.exports=function(r){return Object(e(r))}},sHho:function(r,n){},"vFc/":function(r,n,t){var e=t("TcQ7"),o=t("QRG4"),i=t("fkB2");r.exports=function(r){return function(n,t,a){var s,c=e(n),u=o(c.length),f=i(a,u);if(r&&t!=t){for(;u>f;)if((s=c[f++])!=s)return!0}else for(;u>f;f++)if((r||f in c)&&c[f]===t)return r||f||0;return!r&&-1}}},"vIB/":function(r,n,t){"use strict";var e=t("O4g8"),o=t("kM2E"),i=t("880/"),a=t("hJx8"),s=t("/bQp"),c=t("94VQ"),u=t("e6n0"),f=t("PzxK"),l=t("dSzd")("iterator"),p=!([].keys&&"next"in[].keys()),v=function(){return this};r.exports=function(r,n,t,d,h,y,m){c(t,n,d);var x,g,b,j=function(r){if(!p&&r in O)return O[r];switch(r){case"keys":case"values":return function(){return new t(this,r)}}return function(){return new t(this,r)}},S=n+" Iterator",w="values"==h,P=!1,O=r.prototype,_=O[l]||O["@@iterator"]||h&&O[h],E=_||j(h),k=h?w?j("entries"):E:void 0,M="Array"==n&&O.entries||_;if(M&&(b=f(M.call(new r)))!==Object.prototype&&b.next&&(u(b,S,!0),e||"function"==typeof b[l]||a(b,l,v)),w&&_&&"values"!==_.name&&(P=!0,E=function(){return _.call(this)}),e&&!m||!p&&!P&&O[l]||a(O,l,E),s[n]=E,s[S]=v,h)if(x={values:w?E:j("values"),keys:y?E:j("keys"),entries:k},m)for(g in x)g in O||i(O,g,x[g]);else o(o.P+o.F*(p||P),n,x);return x}},xGkn:function(r,n,t){"use strict";var e=t("4mcu"),o=t("EGZi"),i=t("/bQp"),a=t("TcQ7");r.exports=t("vIB/")(Array,"Array",function(r,n){this._t=a(r),this._i=0,this._k=n},function(){var r=this._t,n=this._k,t=this._i++;return!r||t>=r.length?(this._t=void 0,o(1)):o(0,"keys"==n?t:"values"==n?r[t]:[t,r[t]])},"values"),i.Arguments=i.Array,e("keys"),e("values"),e("entries")},"xH/j":function(r,n,t){var e=t("hJx8");r.exports=function(r,n,t){for(var o in n)t&&r[o]?r[o]=n[o]:e(r,o,n[o]);return r}},xnc9:function(r,n){r.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},yaCO:function(r,n){r.exports='# 定义\r\nMDN 对闭包的定义为：\r\n> 闭包是指那些能够访问自由变量的函数。\r\n\r\n那什么是自由变量呢？\r\n\r\n>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量\r\n\r\n由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量\r\n举个例子：\r\n```javascript\r\nvar a = 1;\r\n\r\nfunction foo() {\r\n    console.log(a);\r\n}\r\n\r\nfoo();\r\n```\r\nfoo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。\r\n那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛……\r\n所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。\r\n咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？\r\n别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义：\r\nECMAScript中，闭包指的是：\r\n1. 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。\r\n2. 从实践角度：以下函数才算是闭包：\r\n即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）\r\n在代码中引用了自由变量\r\n# 分析\r\n让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动：\r\n\r\n```javascript\r\nvar scope = "global scope";\r\nfunction checkscope(){\r\n    var scope = "local scope";\r\n    function f(){\r\n        return scope;\r\n    }\r\n    return f;\r\n}\r\n\r\nvar foo = checkscope();\r\nfoo();\r\n```\r\n首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。\r\n1. 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈\r\n2. 全局执行上下文初始化\r\n3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈\r\n4. checkscope 执行上下文初始化，创建变量对象、作用域链、this等\r\n5. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出\r\n6. 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈\r\n7. f 执行上下文初始化，创建变量对象、作用域链、this等\r\n8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出\r\n\r\n当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？\r\n\r\n以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……)\r\n\r\n然而 JavaScript 却是可以的！\r\n当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：\r\n```javascript\r\nfContext = {\r\n    Scope: [AO, checkscopeContext.AO, globalContext.VO],\r\n}\r\n```\r\n对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。\r\n1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）\r\n2. 在代码中引用了自由变量\r\n\r\n# 必刷题\r\n```javascript\r\nvar data = [];\r\n\r\nfor (var i = 0; i < 3; i++) {\r\n  data[i] = function () {\r\n    console.log(i);\r\n  };\r\n}\r\ndata[0]();\r\ndata[1]();\r\ndata[2]();\r\n```\r\n答案是都是 3，让我们分析一下原因：\r\n当执行到 data[0] 函数之前，此时全局上下文的 VO 为：\r\n```javascript\r\nglobalContext = {\r\n    VO: {\r\n        data: [...],\r\n        i: 3\r\n    }\r\n}\r\n```\r\n当执行 data[0] 函数的时候，data[0] 函数的作用域链为：\r\n```javascript\r\ndata[0]Context = {\r\n    Scope: [AO, globalContext.VO]\r\n}\r\n```\r\ndata[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。\r\n\r\ndata[1] 和 data[2] 是一样的道理。\r\n所以让我们改成闭包看看：\r\n```javascript\r\nvar data = [];\r\n\r\nfor (var i = 0; i < 3; i++) {\r\n  data[i] = (function (i) {\r\n        return function(){\r\n            console.log(i);\r\n        }\r\n  })(i);\r\n}\r\ndata[0]();\r\ndata[1]();\r\ndata[2]();\r\n```\r\n当执行到 data[0] 函数之前，此时全局上下文的 VO 为：\r\n```javascript\r\nglobalContext = {\r\n    VO: {\r\n        data: [...],\r\n        i: 3\r\n    }\r\n}\r\n```\r\n跟没改之前一模一样。\r\n当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：\r\n```javascript\r\ndata[0]Context = {\r\n    Scope: [AO, 匿名函数Context.AO globalContext.VO]\r\n}\r\n```\r\n匿名函数执行上下文的AO为：\r\n```javascript\r\n匿名函数Context = {\r\n    AO: {\r\n        arguments: {\r\n            0: 0,\r\n            length: 1\r\n        },\r\n        i: 0\r\n    }\r\n}\r\n```\r\n\r\n\r\n'},zQR9:function(r,n,t){"use strict";var e=t("h65t")(!0);t("vIB/")(String,"String",function(r){this._t=String(r),this._i=0},function(){var r,n=this._t,t=this._i;return t>=n.length?{value:void 0,done:!0}:(r=e(n,t),this._i+=r.length,{value:r,done:!1})})}});
//# sourceMappingURL=1.2cd5a386e0ec8d2bcc51.js.map